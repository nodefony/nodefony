#!/usr/bin/env node
const path = require("path");
// nodefony
try {
  const nodefony = require("nodefony");
}catch(e){
  const nodefony = require(require("path").resolve( "src", "nodefony", "core", "autoloader"));
}
let type = null ;
let debug = false ;
let kernel = null ;
let environment = "production" ;

const cli = new nodefony.cli("NODEFONY", {
  onStart:() => {
    cli.setCommandOption('-v, --version', 'nodefony version ');
    cli.setCommandOption('-d, --development', 'nodefony server development');
    cli.setCommandOption('-p, --production', 'nodefony server production');
    cli.setCommandOption('-m, --pm2', 'nodefony PM2 server ');
    switch (true){
      case  (!! cli.commander.version ) :
        type = "SERVER";
        if( cli.commander.debug ){
          cli.logger("DEBUG", "INFO");
          debug = true ;
        }
        process.env.MODE_START = "NODEFONY_DEV" ;
        break;
      case  (!! cli.commander.production ) :
        type = "SERVER";
        environment = "development" ;
        if( cli.commander.debug ){
          cli.logger("DEBUG", "INFO");
          debug = true ;
        }
        process.env["MODE_START"] = "NODEFONY" ;
        break;
      case  (!! cli.commander.pm2  ) :
        type = "SERVER";
        cli.logger("PM2", "INFO");
        process.env["MODE_START"] = "PM2" ;
        break;
      case (!! cli.commander.debug ) :
        debug = true ;
      default:
        type = "CONSOLE";
        process.env["MODE_START"] = "NODEFONY_CONSOLE" ;
    }
    start();
  }
});


let start = function (){

  // KERNEL  START
  switch ( process.env["MODE_START"] ){
    case "PM2" :
      kernel = new nodefony.appKernel(environment, debug, type, {});
      break ;

    case "NODEFONY" :
      const cluster = require('cluster');
      if (cluster.isMaster) {
        var nbProc = require('os').cpus().length;
        for (var i=0 ; i < nbProc; i++){
          cluster.fork();
        }
        cluster.on('disconnect', function(worker) {
          console.error('disconnect!');
        });
        cluster.on('fork', (worker) => {
          let wid = worker.id ;
          worker.on('message', (msg) => {
            if ( msg && msg.worker === wid ){
              return ;
            }
            Object.keys(cluster.workers).forEach(function(id) {
              if ( id != wid){
                //console.log("CLUSTER SEND FROM  "+ wid + " to " + id)
                cluster.workers[id].send(nodefony.extend(msg, {
                  worker:wid,
                }));
              }
            });
          });
        });
      }else {
        kernel = new nodefony.appKernel(environment, debug, type, {});
      }
      break ;
    case "NODEFONY_DEV":
      kernel = new nodefony.appKernel(environment, debug, type, {});
      break;
    default:
      process.env["MODE_START"] = "NODEFONY_CONSOLE" ;
      kernel = new nodefony.appKernel(environment, debug, type, {});
  }
}
module.exports = cli ;
return cli;




















/*
const arg = process.argv.slice(2)[0];
switch ( arg ){
  case "app" :
		try {
			var config = yaml.load( fs.readFileSync( path.resolve( "app", "config", "config.yml"), 'utf8' ) );
			return process.stdout.write( config.App.projectName );
		}catch(e){
			return process.stdout.write( "nodefony" );
		}
	case "version" :
		try {
			var nodefony_version = require( path.resolve( "package.json") ).version;
			return process.stdout.write( nodefony_version );
		}catch(e){
			throw e ;
		}
	case "config" :
		var config = yaml.load( fs.readFileSync( path.resolve( "app", "config", "config.yml"), 'utf8' ) );
		return  process.stdout.write( JSON.stringify(config, null, '\t') );
	case "check-version" :
		const semver = require('semver');
		var nodefony_version = require( path.resolve( "package.json") ).version;
		var res = semver.valid(nodefony_versionn);
		if ( res ){
				return  process.stdout.write(res) ;
		}
		throw new Error ("Not valid version : " + nodefony_version +" check  http://semver.org ");
  case "dev" :
  case "--dev" :
  case "development" :
    process.env["MODE_START"] = "NODEFONY_DEV";
    break;
  case "prod" :
  case "--prod" :
  case "production" :
    process.env["MODE_START"] = "NODEFONY";
    break;
}


// KERNEL  START
const kernel  = null ;
switch ( process.env["MODE_START"] ){

  case "PM2" :
    kernel = new nodefony.appKernel();
    break ;

  case "NODEFONY" :
    const cluster = require('cluster');
    if (cluster.isMaster) {
      var nbProc = require('os').cpus().length;
      for (var i=0 ; i < nbProc; i++){
        cluster.fork();
      }
      cluster.on('disconnect', function(worker) {
        console.error('disconnect!');
      });
      cluster.on('fork', (worker) => {
        let wid = worker.id ;
        worker.on('message', (msg) => {
          if ( msg && msg.worker === wid ){
            return ;
          }
          Object.keys(cluster.workers).forEach(function(id) {
            if ( id != wid){
              //console.log("CLUSTER SEND FROM  "+ wid + " to " + id)
              cluster.workers[id].send(nodefony.extend(msg, {
                worker:wid,
              }));
            }
          });
        });
      });
      return ;
    }else {
      const kernel = new nodefony.appKernel();
    }
    break ;

  case "NODEFONY_DEV":
    kernel = new nodefony.appKernel();
    break;

  default:
    process.env["MODE_START"] = "NODEFONY_CONSOLE" ;
    kernel = new nodefony.appKernel();
}

module.exports = kernel ;
*/
