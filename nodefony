#!/usr/bin/env node
const cluster = require('cluster');
const path = require("path");
const fs = require("fs");
const shell = require("shelljs");

try {
	const nodefony = require("nodefony");
}catch(e){
	const nodefony = require(".", "src", "nodefony", "core", "autoloader");
}
process.env.BABEL_ENV = 'production';
process.env.NODE_ENV = 'production';
/*
 *
 * NODEFONY FRAMEWORK START WITH PM2
 *
 *	PRODUCTION
 *
 */
if ( process.env["MODE_START"] && process.env["MODE_START"] === "PM2"){
	var kernel = new nodefony.appKernel("SERVER", "prod", false, {
		node_start:process.env["MODE_START"]
	});
	return kernel ;
}

/*
 *
 * NODEFONY FRAMEWORK START
 *
 *	PRODUCTION ( preprod )
 *
 */
process.env["MODE_START"] = "NODEFONY" ;
if (cluster.isMaster) {

	var links = path.resolve(".", "tmp", "assestLink" ) ;
	if ( fs.existsSync( links) ){
		console.log("DELETE TMP :" + links)
		shell.rm("-Rf", links);
	}

	var webpack = path.resolve(".", "tmp", "webpack" ) ;
	if ( fs.existsSync( webpack) ){
		console.log("DELETE TMP :" + webpack)
		shell.rm("-Rf", webpack);
	}

	var nbProc = require('os').cpus().length;
	for (var i=0 ; i < nbProc; i++){
		cluster.fork();
	}
	cluster.on('disconnect', function(worker) {
		console.error('disconnect!');
	});
	cluster.on('fork', (worker) => {
		let wid = worker.id ;
		worker.on('message', (msg) => {
			if ( msg && msg.worker === wid ){
				return ;
			}
			Object.keys(cluster.workers).forEach(function(id) {
				if ( id != wid){
					//console.log("CLUSTER SEND FROM  "+ wid + " to " + id)
					cluster.workers[id].send(nodefony.extend(msg, {
						worker:wid,
					}));
				}
			});
		});
	});
}else {
	const kernel = new nodefony.appKernel("SERVER", "prod", false, {
		node_start:process.env["MODE_START"]
	});
	return kernel ;
}
